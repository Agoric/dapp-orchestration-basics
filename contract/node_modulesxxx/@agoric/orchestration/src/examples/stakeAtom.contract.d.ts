export namespace meta {
    namespace privateArgsShape {
        export let orchestration: import("@endo/patterns").Matcher;
        export { StorageNodeShape as storageNode };
        export let marshaller: import("@endo/patterns").Matcher;
        export { TimerServiceShape as timer };
    }
}
export namespace privateArgsShape { }
export function start(zcf: ZCF<StakeAtomTerms>, privateArgs: {
    orchestration: import("@endo/exo").Guarded<{
        makeAccount(hostConnectionId: `connection-${number}`, controllerConnectionId: `connection-${number}`): Promise<import("../cosmos-api.js").IcaAccount>;
        provideICQConnection(controllerConnectionId: `connection-${number}`): Promise<import("@endo/exo").Guarded<{
            getLocalAddress(): `/ibc-port/${string}`;
            getRemoteAddress(): `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}`;
            query(msgs: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").RequestQuery>[]): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").ResponseQuery>[]>;
        }>>;
    }>;
    storageNode: StorageNode;
    marshaller: Marshaller;
    timer: TimerService;
}, baggage: Baggage): Promise<{
    publicFacet: import("@endo/exo").Guarded<{
        makeAccount(): Promise<import("@endo/exo").Guarded<{
            getPublicTopics(): {
                account: {
                    description: string;
                    subscriber: globalThis.Subscriber<import("../exos/stakingAccountKit.js").StakingAccountNotification>;
                    storagePath: Promise<string>;
                };
            };
            getAddress(): import("../orchestration-api.js").ChainAddress;
            delegate(validator: import("../cosmos-api.js").CosmosValidatorAddress, amount: import("../orchestration-api.js").AmountArg): Promise<void>;
            redelegate(srcValidator: import("../cosmos-api.js").CosmosValidatorAddress, dstValidator: import("../cosmos-api.js").CosmosValidatorAddress, amount: import("../orchestration-api.js").AmountArg): Promise<void>;
            withdrawReward(validator: import("../cosmos-api.js").CosmosValidatorAddress): Promise<import("../orchestration-api.js").DenomAmount[]>;
            getBalance(denom?: string | undefined): Promise<import("../orchestration-api.js").DenomAmount>;
            withdrawRewards(): never;
            undelegate(delegations: import("@agoric/cosmic-proto/cosmos/staking/v1beta1/staking.js").Delegation[]): Promise<void>;
        }>>;
        makeAccountInvitationMaker(): Promise<Invitation<{
            publicSubscribers: {
                account: {
                    description: string;
                    subscriber: globalThis.Subscriber<import("../exos/stakingAccountKit.js").StakingAccountNotification>;
                    storagePath: Promise<string>;
                };
            };
            invitationMakers: import("@endo/exo").Guarded<{
                Delegate(validator: import("../cosmos-api.js").CosmosValidatorAddress, amount: Amount<"nat">): Promise<Invitation<void, undefined>>;
                Redelegate(srcValidator: import("../cosmos-api.js").CosmosValidatorAddress, dstValidator: import("../cosmos-api.js").CosmosValidatorAddress, amount: import("../orchestration-api.js").AmountArg): Promise<Invitation<void, undefined>>;
                WithdrawReward(validator: import("../cosmos-api.js").CosmosValidatorAddress): Promise<Invitation<import("../orchestration-api.js").DenomAmount[], undefined>>;
                Undelegate(delegations: import("@agoric/cosmic-proto/cosmos/staking/v1beta1/staking.js").Delegation[]): Promise<Invitation<void, undefined>>;
                CloseAccount(): never;
                TransferAccount(): never;
            }>;
            account: import("@endo/exo").Guarded<{
                getPublicTopics(): {
                    account: {
                        description: string;
                        subscriber: globalThis.Subscriber<import("../exos/stakingAccountKit.js").StakingAccountNotification>;
                        storagePath: Promise<string>;
                    };
                };
                getAddress(): import("../orchestration-api.js").ChainAddress;
                delegate(validator: import("../cosmos-api.js").CosmosValidatorAddress, amount: import("../orchestration-api.js").AmountArg): Promise<void>;
                redelegate(srcValidator: import("../cosmos-api.js").CosmosValidatorAddress, dstValidator: import("../cosmos-api.js").CosmosValidatorAddress, amount: import("../orchestration-api.js").AmountArg): Promise<void>;
                withdrawReward(validator: import("../cosmos-api.js").CosmosValidatorAddress): Promise<import("../orchestration-api.js").DenomAmount[]>;
                getBalance(denom?: string | undefined): Promise<import("../orchestration-api.js").DenomAmount>;
                withdrawRewards(): never;
                undelegate(delegations: import("@agoric/cosmic-proto/cosmos/staking/v1beta1/staking.js").Delegation[]): Promise<void>;
            }>;
        }, undefined>>;
    }>;
}>;
export type StakeAtomTerms = {
    hostConnectionId: `connection-${number}`;
    controllerConnectionId: `connection-${number}`;
    bondDenom: string;
};
export type StakeAtomSF = typeof start;
import { StorageNodeShape } from '@agoric/internal';
import { TimerServiceShape } from '@agoric/time';
import type { TimerService } from '@agoric/time';
import type { Baggage } from '@agoric/vat-data';
//# sourceMappingURL=stakeAtom.contract.d.ts.map