export function start(zcf: ZCF, privateArgs: {
    localchain: import("@agoric/vats/src/localchain.js").LocalChain;
    marshaller: Marshaller;
    storageNode: StorageNode;
    timerService: TimerService;
    timerBrand: TimerBrand;
}, baggage: import("@agoric/vat-data").Baggage): Promise<{
    publicFacet: import("@endo/exo").Guarded<{
        /**
         * Invitation to make an account, initialized with the give's BLD
         */
        makeStakeBldInvitation(): Promise<Invitation<{
            publicSubscribers: {
                account: {
                    description: string;
                    subscriber: globalThis.Subscriber<import("../exos/local-chain-account-kit.js").LocalChainAccountNotification>;
                    storagePath: Promise<string>;
                };
            };
            invitationMakers: import("@endo/exo").Guarded<{
                Delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<Invitation<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
                    '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
                }>, undefined>>;
                Undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<Invitation<void, undefined>>;
                CloseAccount(): never;
            }>;
            account: import("@endo/exo").Guarded<{
                getPublicTopics(): {
                    account: {
                        description: string;
                        subscriber: globalThis.Subscriber<import("../exos/local-chain-account-kit.js").LocalChainAccountNotification>;
                        storagePath: Promise<string>;
                    };
                };
                delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
                    '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
                }>>;
                undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<void>;
                deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
                withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
                executeTx<MT extends {
                    '@type': string;
                }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto").ResponseTo<MT[K]>>; }>;
                getAddress(): string;
                transfer(amount: import("../orchestration-api.js").AmountArg, destination: import("../orchestration-api.js").ChainAddress, opts?: import("../cosmos-api.js").IBCMsgTransferOptions | undefined): Promise<void>;
            }>;
        }, undefined>>;
        makeAccount(): Promise<import("@endo/exo").Guarded<{
            getPublicTopics(): {
                account: {
                    description: string;
                    subscriber: globalThis.Subscriber<import("../exos/local-chain-account-kit.js").LocalChainAccountNotification>;
                    storagePath: Promise<string>;
                };
            };
            delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
                '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
            }>>;
            undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<void>;
            deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
            withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
            executeTx<MT extends {
                '@type': string;
            }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto").ResponseTo<MT[K]>>; }>;
            getAddress(): string;
            transfer(amount: import("../orchestration-api.js").AmountArg, destination: import("../orchestration-api.js").ChainAddress, opts?: import("../cosmos-api.js").IBCMsgTransferOptions | undefined): Promise<void>;
        }>>;
        /**
         * Invitation to make an account, without any funds
         */
        makeAccountInvitationMaker(): Promise<Invitation<{
            publicSubscribers: {
                account: {
                    description: string;
                    subscriber: globalThis.Subscriber<import("../exos/local-chain-account-kit.js").LocalChainAccountNotification>;
                    storagePath: Promise<string>;
                };
            };
            invitationMakers: import("@endo/exo").Guarded<{
                Delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<Invitation<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
                    '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
                }>, undefined>>;
                Undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<Invitation<void, undefined>>;
                CloseAccount(): never;
            }>;
            account: import("@endo/exo").Guarded<{
                getPublicTopics(): {
                    account: {
                        description: string;
                        subscriber: globalThis.Subscriber<import("../exos/local-chain-account-kit.js").LocalChainAccountNotification>;
                        storagePath: Promise<string>;
                    };
                };
                delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
                    '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
                }>>;
                undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<void>;
                deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
                withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
                executeTx<MT extends {
                    '@type': string;
                }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto").ResponseTo<MT[K]>>; }>;
                getAddress(): string;
                transfer(amount: import("../orchestration-api.js").AmountArg, destination: import("../orchestration-api.js").ChainAddress, opts?: import("../cosmos-api.js").IBCMsgTransferOptions | undefined): Promise<void>;
            }>;
        }, undefined>>;
    }>;
}>;
import type { TimerService } from '@agoric/time';
import type { TimerBrand } from '@agoric/time';
//# sourceMappingURL=stakeBld.contract.d.ts.map