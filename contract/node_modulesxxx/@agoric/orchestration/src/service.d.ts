export const OrchestrationI: import("@endo/patterns").InterfaceGuard<{
    makeAccount: import("@endo/patterns").MethodGuard;
    provideICQConnection: import("@endo/patterns").MethodGuard;
}>;
export function prepareOrchestrationTools(zone: Zone): {
    makeOrchestrationKit: (initialPowers?: Partial<OrchestrationPowers> | undefined) => import("@endo/exo").GuardedKit<{
        self: {
            allocateICAControllerPort(): Promise<any>;
            allocateICQControllerPort(): Promise<any>;
        };
        public: {
            /**
             * @param {IBCConnectionID} hostConnectionId
             *   the counterparty connection_id
             * @param {IBCConnectionID} controllerConnectionId
             *   self connection_id
             * @returns {Promise<IcaAccount>}
             */
            makeAccount(hostConnectionId: `connection-${number}`, controllerConnectionId: `connection-${number}`): Promise<IcaAccount>;
            /**
             * @param {IBCConnectionID} controllerConnectionId
             * @returns {Promise<ICQConnection>}
             */
            provideICQConnection(controllerConnectionId: `connection-${number}`): Promise<import("@endo/exo").Guarded<{
                getLocalAddress(): `/ibc-port/${string}`;
                getRemoteAddress(): `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}`;
                query(msgs: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").RequestQuery>[]): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").ResponseQuery>[]>;
            }>>;
        };
    }>;
};
export type OrchestrationPowers = {
    portAllocator: Remote<import("@endo/exo").Guarded<{
        allocateCustomIBCPort(specifiedName?: string): import("@agoric/vow").Vow<any>;
        allocateICAControllerPort(): import("@agoric/vow").Vow<any>;
        allocateICQControllerPort(): import("@agoric/vow").Vow<any>;
        allocateCustomLocalPort(specifiedName?: string): import("@agoric/vow").Vow<any>;
    }>>;
};
/**
 * PowerStore is used so additional powers can be added on upgrade. See
 * [#7337](https://github.com/Agoric/agoric-sdk/issues/7337) for tracking on Exo
 * state migrations.
 */
export type PowerStore = MapStore<keyof OrchestrationPowers, OrchestrationPowers[keyof OrchestrationPowers]>;
export type ICQConnectionStore = import("@endo/pass-style").RemotableObject & import("@agoric/store").MapStoreMethods<`connection-${number}`, import("@endo/exo").GuardedKit<{
    connection: {
        getLocalAddress(): `/ibc-port/${string}`;
        getRemoteAddress(): `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}`;
        query(msgs: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").RequestQuery>[]): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").ResponseQuery>[]>;
    };
    connectionHandler: {
        onOpen(connection: Remote<import("@agoric/network").Connection>, localAddr: `/ibc-port/${string}`, remoteAddr: `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}`): Promise<void>;
        onClose(_connection: any, reason: any): Promise<void>;
        onReceive(connection: any, bytes: any): Promise<string>;
    };
}>>;
export type OrchestrationState = {
    powers: PowerStore;
    icqConnections: ICQConnectionStore;
};
export type OrchestrationTools = ReturnType<typeof prepareOrchestrationTools>;
export type OrchestrationKit = ReturnType<OrchestrationTools["makeOrchestrationKit"]>;
export type OrchestrationService = OrchestrationKit["public"];
import type { Zone } from '@agoric/base-zone';
import type { IcaAccount } from './types.js';
import type { Remote } from '@agoric/internal';
//# sourceMappingURL=service.d.ts.map