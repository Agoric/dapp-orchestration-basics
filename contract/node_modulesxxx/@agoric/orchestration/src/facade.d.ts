export function makeOrchestrationFacade({ zone, timerService, zcf, storageNode, orchestrationService, localchain, }: {
    zone: Zone;
    timerService: Remote<TimerService> | null;
    zcf: ZCF;
    storageNode: Remote<globalThis.StorageNode>;
    orchestrationService: Remote<import("@endo/exo").Guarded<{
        makeAccount(hostConnectionId: `connection-${number}`, controllerConnectionId: `connection-${number}`): Promise<import("./cosmos-api.js").IcaAccount>;
        provideICQConnection(controllerConnectionId: `connection-${number}`): Promise<import("@endo/exo").Guarded<{
            getLocalAddress(): `/ibc-port/${string}`;
            getRemoteAddress(): `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}`;
            query(msgs: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").RequestQuery>[]): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").ResponseQuery>[]>;
        }>>;
    }>> | null;
    localchain: Remote<import("@endo/exo").Guarded<{
        makeAccount(): Promise<import("@endo/exo").Guarded<{
            getAddress(): Promise<string>;
            getBalance(brand: Brand<"nat">): Promise<import("@agoric/ertp/src/types.js").NatAmount>;
            deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
            withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
            executeTx<MT extends {
                '@type': string;
            }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto").ResponseTo<MT[K]>>; }>;
        }>>;
        query(request: import("@agoric/cosmic-proto").TypedJson): Promise<{
            '@type': string;
        }>;
        queryMany(requests: import("@agoric/cosmic-proto").TypedJson[]): Promise<{
            error?: string | undefined;
            reply: {
                '@type': string;
            };
        }[]>;
    }>>;
}): {
    /**
     * @template Context
     * @template {any[]} Args
     * @param {string} durableName
     * @param {Context} ctx
     * @param {(orc: Orchestrator, ctx2: Context, ...args: Args) => object} fn
     * @returns {(...args: Args) => Promise<unknown>}
     */
    orchestrate<Context, Args extends any[]>(durableName: string, ctx: Context, fn: (orc: Orchestrator, ctx2: Context, ...args: Args) => object): (...args: Args) => Promise<unknown>;
};
export type OrchestrationFacade = ReturnType<typeof makeOrchestrationFacade>;
import type { Zone } from '@agoric/zone';
import type { TimerService } from '@agoric/time';
import type { Remote } from '@agoric/internal';
import type { Orchestrator } from './types.js';
//# sourceMappingURL=facade.d.ts.map