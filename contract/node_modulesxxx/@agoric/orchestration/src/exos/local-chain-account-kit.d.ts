export function prepareLocalChainAccountKit(zone: Zone, makeRecorderKit: <T>(storageNode: StorageNode | Awaited<import("@endo/far").FarRef<StorageNode>>, valueShape?: import("@agoric/zoe/src/contractSupport/recorder.js").TypedMatcher<T> | undefined) => RecorderKit<T>, zcf: ZCF, timerService: TimerService, timerBrand: TimerBrand, agoricChainInfo: AgoricChainInfo): (args_0: {
    account: import("@endo/exo").Guarded<{
        getAddress(): Promise<string>;
        getBalance(brand: Brand<"nat">): Promise<import("@agoric/ertp/src/types.js").NatAmount>;
        deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
        withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
        executeTx<MT extends {
            '@type': string;
        }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/vatsafe").ResponseTo<MT[K]>>; }>;
    }>;
    address: string;
    storageNode: StorageNode;
}) => import("@endo/exo").GuardedKit<{
    invitationMakers: {
        /**
         *
         * @param {string} validatorAddress
         * @param {Amount<'nat'>} ertpAmount
         */
        Delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<Invitation<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
            '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
        }>, undefined>>;
        /**
         * @param {string} validatorAddress
         * @param {Amount<'nat'>} ertpAmount
         */
        Undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<Invitation<void, undefined>>;
        CloseAccount(): never;
    };
    holder: {
        getPublicTopics(): {
            account: {
                description: string;
                subscriber: globalThis.Subscriber<LocalChainAccountNotification>;
                storagePath: Promise<string>;
            };
        };
        /**
         *
         * @param {string} validatorAddress
         * @param {Amount<'nat'>} ertpAmount
         */
        delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
            '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
        }>>;
        /**
         *
         * @param {string} validatorAddress
         * @param {Amount<'nat'>} ertpAmount
         * @returns {Promise<void>}
         */
        undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<void>;
        /**
         * Starting a transfer revokes the account holder. The associated updater
         * will get a special notification that the account is being transferred.
         */
        /** @type {LocalChainAccount['deposit']} */
        deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
        /** @type {LocalChainAccount['withdraw']} */
        withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
        /** @type {LocalChainAccount['executeTx']} */
        executeTx<MT extends {
            '@type': string;
        }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/vatsafe").ResponseTo<MT[K]>>; }>;
        /**
         * @returns {ChainAddress['address']}
         */
        getAddress(): string;
        /**
         * @param {AmountArg} amount an ERTP {@link Amount} or a {@link DenomAmount}
         * @param {ChainAddress} destination
         * @param {IBCMsgTransferOptions} [opts] if either timeoutHeight or timeoutTimestamp are not supplied, a default timeoutTimestamp will be set for 5 minutes in the future
         * @returns {Promise<void>}
         */
        transfer(amount: AmountArg, destination: ChainAddress, opts?: IBCMsgTransferOptions | undefined): Promise<void>;
    };
}>;
export type AgoricChainInfo = {
    connections: globalThis.MapStore<string, import("@agoric/orchestration").IBCConnectionInfo>;
};
export type LocalChainAccountNotification = {
    address: string;
};
export type State = {
    topicKit: RecorderKit<LocalChainAccountNotification>;
    account: import("@endo/exo").Guarded<{
        getAddress(): Promise<string>;
        getBalance(brand: Brand<"nat">): Promise<import("@agoric/ertp/src/types.js").NatAmount>;
        deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
        withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
        executeTx<MT extends {
            '@type': string;
        }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/vatsafe").ResponseTo<MT[K]>>; }>;
    }>;
    address: string;
};
export type LocalChainAccountKit = ReturnType<ReturnType<typeof prepareLocalChainAccountKit>>;
import type { Zone } from '@agoric/zone';
import type { RecorderKit } from '@agoric/zoe/src/contractSupport/recorder.js';
import type { TimerService } from '@agoric/time';
import type { TimerBrand } from '@agoric/time';
import type { AmountArg } from '@agoric/orchestration';
import type { ChainAddress } from '@agoric/orchestration';
import type { IBCMsgTransferOptions } from '@agoric/orchestration';
//# sourceMappingURL=local-chain-account-kit.d.ts.map