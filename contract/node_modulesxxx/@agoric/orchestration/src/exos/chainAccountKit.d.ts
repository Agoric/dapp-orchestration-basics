export const ChainAccountI: import("@endo/patterns").InterfaceGuard<{
    getAddress: import("@endo/patterns").MethodGuard;
    getLocalAddress: import("@endo/patterns").MethodGuard;
    getRemoteAddress: import("@endo/patterns").MethodGuard;
    getPort: import("@endo/patterns").MethodGuard;
    executeTx: import("@endo/patterns").MethodGuard;
    executeEncodedTx: import("@endo/patterns").MethodGuard;
    close: import("@endo/patterns").MethodGuard;
    deposit: import("@endo/patterns").MethodGuard;
    getPurse: import("@endo/patterns").MethodGuard;
}>;
export function prepareChainAccountKit(zone: Zone): (port: Port, requestedRemoteAddress: string) => import("@endo/exo").GuardedKit<{
    account: {
        /**
         * @returns {ChainAddress}
         */
        getAddress(): ChainAddress;
        getLocalAddress(): `/ibc-port/${string}`;
        getRemoteAddress(): `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}`;
        getPort(): Port;
        executeTx(): never;
        /**
         * Submit a transaction on behalf of the remote account for execution on the remote chain.
         * @param {AnyJson[]} msgs
         * @param {Omit<TxBody, 'messages'>} [opts]
         * @returns {Promise<string>} - base64 encoded bytes string. Can be decoded using the corresponding `Msg*Response` object.
         * @throws {Error} if packet fails to send or an error is returned
         */
        executeEncodedTx(msgs: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/google/protobuf/any.js").Any>[], opts?: Omit<TxBody, "messages"> | undefined): Promise<string>;
        /**
         * Close the remote account
         */
        close(): Promise<void>;
        deposit(payment: any): Promise<never>;
        /**
         * get Purse for a brand to .withdraw() a Payment from the account
         * @param {Brand} brand
         */
        getPurse(brand: Brand): Promise<never>;
    };
    connectionHandler: {
        /**
         * @param {Remote<Connection>} connection
         * @param {LocalIbcAddress} localAddr
         * @param {RemoteIbcAddress} remoteAddr
         */
        onOpen(connection: Remote<Connection>, localAddr: `/ibc-port/${string}`, remoteAddr: `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}`): Promise<void>;
        onClose(_connection: any, reason: any): Promise<void>;
        onReceive(connection: any, bytes: any): Promise<string>;
    };
}>;
export type UnparsableChainAddress = "UNPARSABLE_CHAIN_ADDRESS";
export type State = {
    port: Port;
    connection: Remote<Connection> | undefined;
    localAddress: `/ibc-port/${string}` | undefined;
    requestedRemoteAddress: string;
    remoteAddress: `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}` | undefined;
    chainAddress: ChainAddress | undefined;
};
export type ChainAccountKit = ReturnType<ReturnType<typeof prepareChainAccountKit>>;
import type { Zone } from '@agoric/base-zone';
import type { Port } from '@agoric/network';
import type { ChainAddress } from '../types.js';
import type { TxBody } from '@agoric/cosmic-proto/cosmos/tx/v1beta1/tx.js';
import type { Connection } from '@agoric/network';
import type { Remote } from '@agoric/vow';
//# sourceMappingURL=chainAccountKit.d.ts.map