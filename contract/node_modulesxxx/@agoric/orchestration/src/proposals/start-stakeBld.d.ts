export function startStakeBld({ consume: { board, chainStorage, chainTimerService: chainTimerServiceP, localchain, startUpgradable, }, installation: { consume: { stakeBld }, }, instance: { produce: { stakeBld: produceInstance }, }, issuer: { consume: { [Stake.symbol]: stakeIssuer }, }, }: BootstrapPowers & {
    installation: {
        consume: {
            stakeBld: Installation<(zcf: ZCF, privateArgs: {
                localchain: import("@endo/exo").Guarded<{
                    makeAccount(): Promise<import("@endo/exo").Guarded<{
                        getAddress(): Promise<string>;
                        getBalance(brand: Brand<"nat">): Promise<import("@agoric/ertp/src/types.js").NatAmount>;
                        deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
                        withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
                        executeTx<MT extends {
                            '@type': string;
                        }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto").ResponseTo<MT[K]>>; }>;
                    }>>;
                    query(request: import("@agoric/cosmic-proto").TypedJson): Promise<{
                        '@type': string;
                    }>;
                    queryMany(requests: import("@agoric/cosmic-proto").TypedJson[]): Promise<{
                        error?: string | undefined;
                        reply: {
                            '@type': string;
                        };
                    }[]>;
                }>;
                marshaller: {
                    toCapData: import("@endo/marshal").ToCapData<unknown>;
                    fromCapData: import("@endo/marshal").FromCapData<unknown>;
                    serialize: import("@endo/marshal").ToCapData<unknown>;
                    unserialize: import("@endo/marshal").FromCapData<unknown>;
                };
                storageNode: globalThis.StorageNode;
                timerService: import("@agoric/time").TimerService;
                timerBrand: import("@agoric/time").TimerBrand;
            }, baggage: import("@agoric/vat-data").Baggage) => Promise<{
                publicFacet: import("@endo/exo").Guarded<{
                    makeStakeBldInvitation(): Promise<Invitation<{
                        publicSubscribers: {
                            account: {
                                description: string;
                                subscriber: globalThis.Subscriber<import("../exos/local-chain-account-kit.js").LocalChainAccountNotification>;
                                storagePath: Promise<string>;
                            };
                        };
                        invitationMakers: import("@endo/exo").Guarded<{
                            Delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<Invitation<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
                                '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
                            }>, undefined>>;
                            Undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<Invitation<void, undefined>>;
                            CloseAccount(): never;
                        }>;
                        account: import("@endo/exo").Guarded<{
                            getPublicTopics(): {
                                account: {
                                    description: string;
                                    subscriber: globalThis.Subscriber<import("../exos/local-chain-account-kit.js").LocalChainAccountNotification>;
                                    storagePath: Promise<string>;
                                };
                            };
                            delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
                                '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
                            }>>;
                            undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<void>;
                            deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
                            withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
                            executeTx<MT extends {
                                '@type': string;
                            }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto").ResponseTo<MT[K]>>; }>;
                            getAddress(): string;
                            transfer(amount: import("../orchestration-api.js").AmountArg, destination: import("../orchestration-api.js").ChainAddress, opts?: import("../cosmos-api.js").IBCMsgTransferOptions | undefined): Promise<void>;
                        }>;
                    }, undefined>>;
                    makeAccount(): Promise<import("@endo/exo").Guarded<{
                        getPublicTopics(): {
                            account: {
                                description: string;
                                subscriber: globalThis.Subscriber<import("../exos/local-chain-account-kit.js").LocalChainAccountNotification>;
                                storagePath: Promise<string>;
                            };
                        };
                        delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
                            '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
                        }>>;
                        undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<void>;
                        deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
                        withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
                        executeTx<MT extends {
                            '@type': string;
                        }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto").ResponseTo<MT[K]>>; }>;
                        getAddress(): string;
                        transfer(amount: import("../orchestration-api.js").AmountArg, destination: import("../orchestration-api.js").ChainAddress, opts?: import("../cosmos-api.js").IBCMsgTransferOptions | undefined): Promise<void>;
                    }>>;
                    makeAccountInvitationMaker(): Promise<Invitation<{
                        publicSubscribers: {
                            account: {
                                description: string;
                                subscriber: globalThis.Subscriber<import("../exos/local-chain-account-kit.js").LocalChainAccountNotification>;
                                storagePath: Promise<string>;
                            };
                        };
                        invitationMakers: import("@endo/exo").Guarded<{
                            Delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<Invitation<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
                                '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
                            }>, undefined>>;
                            Undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<Invitation<void, undefined>>;
                            CloseAccount(): never;
                        }>;
                        account: import("@endo/exo").Guarded<{
                            getPublicTopics(): {
                                account: {
                                    description: string;
                                    subscriber: globalThis.Subscriber<import("../exos/local-chain-account-kit.js").LocalChainAccountNotification>;
                                    storagePath: Promise<string>;
                                };
                            };
                            delegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/cosmos/staking/v1beta1/tx.js").MsgDelegateResponse & {
                                '@type': "/cosmos.staking.v1beta1.MsgDelegateResponse";
                            }>>;
                            undelegate(validatorAddress: string, ertpAmount: Amount<"nat">): Promise<void>;
                            deposit(payment: Payment<"nat">, optAmountShape?: Pattern): Promise<globalThis.Amount>;
                            withdraw(amount: Amount<"nat">): Promise<globalThis.Payment<"nat">>;
                            executeTx<MT extends {
                                '@type': string;
                            }[]>(messages: MT): Promise<{ [K in keyof MT]: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto").ResponseTo<MT[K]>>; }>;
                            getAddress(): string;
                            transfer(amount: import("../orchestration-api.js").AmountArg, destination: import("../orchestration-api.js").ChainAddress, opts?: import("../cosmos-api.js").IBCMsgTransferOptions | undefined): Promise<void>;
                        }>;
                    }, undefined>>;
                }>;
            }>>;
        };
    };
}): Promise<void>;
export function getManifestForStakeBld({ restoreRef }: {
    restoreRef: any;
}, { installKeys }: {
    installKeys: any;
}): {
    manifest: {
        [x: string]: {
            consume: {
                board: boolean;
                chainStorage: boolean;
                chainTimerService: boolean;
                localchain: boolean;
                startUpgradable: boolean;
            };
            installation: {
                consume: {
                    stakeBld: boolean;
                };
            };
            instance: {
                produce: {
                    stakeBld: boolean;
                };
            };
            issuer: {
                consume: {
                    BLD: boolean;
                };
            };
        };
    };
    installations: {
        stakeBld: any;
    };
};
import { Stake } from '@agoric/internal/src/tokens.js';
//# sourceMappingURL=start-stakeBld.d.ts.map