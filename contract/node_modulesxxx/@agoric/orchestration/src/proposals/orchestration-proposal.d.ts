export function setupOrchestrationVat({ consume: { loadCriticalVat, portAllocator: portAllocatorP }, produce: { orchestrationVat, orchestration, orchestrationKit: orchestrationKitP, }, }: WellKnownSpaces & PromiseSpaceOf<ChainBootstrapSpaceT & {
    vatAdminSvc: VatAdminSvc;
}, {}, {
    loadVat: VatLoader<unknown>;
    loadCriticalVat: VatLoader<unknown>;
}> & {
    zone: import("@agoric/base-zone").Zone;
    devices: SoloDevices | ChainDevices;
    vats: SwingsetVats;
    vatPowers: {
        [prop: string]: any;
        D: DProxy<any>;
    };
    vatParameters: BootstrapVatParams;
    runBehaviors: (manifest: unknown) => Promise<unknown>;
    modules: {
        behaviors: {
            bridgeCoreEval: (allPowers: BootstrapPowers) => Promise<void>;
            makeProvisioner: ({ consume: { clientCreator, loadCriticalVat }, vats: { comms, vattp }, produce: { provisioning }, }: BootstrapPowers & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<ProvisioningVat>>;
                };
            }) => Promise<void>;
            noProvisioner: ({ produce: { provisioning } }: BootstrapPowers) => Promise<void>;
            bridgeProvisioner: ({ consume: { provisioning: provisioningP, provisionBridgeManager: provisionBridgeManagerP, provisionWalletBridgeManager: provisionWalletBridgeManagerP, }, }: BootstrapPowers) => Promise<void>;
            setupClientManager: ({ produce: { client, clientCreator: clientCreatorP } }: BootstrapSpace, { template, }?: {
                template?: Record<string, unknown>;
            }) => Promise<void>;
            startTimerService: ({ devices: { timer: timerDevice }, vats: { timer: timerVat }, consume: { client }, produce: { chainTimerService: produceTimer }, brand: { produce: { timer }, }, }: BootstrapPowers) => Promise<void>;
            makeBridgeManager: ({ consume: { loadCriticalVat }, devices: { bridge }, produce: { bridgeManager: bridgeManagerP, provisionBridgeManager, provisionWalletBridgeManager, walletBridgeManager, }, }: BootDevices<ChainDevices> & BootstrapSpace & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<ChainStorageVat>>;
                };
            }) => Promise<void>;
            makeChainStorage: ({ consume: { loadCriticalVat, bridgeManager: bridgeManagerP }, produce: { chainStorage: chainStorageP, storageBridgeManager: storageBridgeManagerP, }, }: BootstrapSpace & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<ChainStorageVat>>;
                };
            }) => Promise<void>;
            produceHighPrioritySendersManager: ({ consume: { loadCriticalVat, storageBridgeManager: storageBridgeManagerP }, produce: { highPrioritySendersManager: managerP }, }: BootstrapSpace & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<ChainStorageVat>>;
                };
            }) => Promise<void>;
            publishAgoricNamesToChainStorage: ({ consume: { chainStorage: rootP }, namedVat: { consume: { agoricNames, board: vatBoard }, }, }: BootstrapPowers & NamedVatPowers) => Promise<void>;
            publishAgoricNames: ({ consume: { agoricNamesAdmin, board, chainStorage: rootP } }: BootstrapPowers, { options: { agoricNamesOptions } }?: {
                options?: {
                    agoricNamesOptions?: {
                        topLevel?: string[];
                    };
                };
            }) => Promise<void>;
            connectChainFaucet: ({ consume: { client } }: BootstrapPowers) => Promise<void>;
            makeVatsFromBundles: ({ vats, devices, consume: { vatStore }, produce: { vatAdminSvc, loadVat, loadCriticalVat }, }: BootstrapPowers & {}) => Promise<void>;
            produceDiagnostics: ({ produce }: Pick<ChainBootstrapSpace, "produce">) => Promise<void>;
            produceStartUpgradable: ({ zone, consume: { diagnostics, zoe }, produce, }: BootstrapSpace & {
                zone: import("@agoric/zone").Zone;
            }) => Promise<void>;
            produceStartGovernedUpgradable: ({ zone, consume: { chainTimerService, diagnostics, economicCommitteeCreatorFacet, zoe, }, produce, installation: { consume: { contractGovernor }, }, }: BootstrapSpace & {
                zone: import("@agoric/zone").Zone;
                consume: {
                    economicCommitteeCreatorFacet: import("@agoric/inter-protocol/src/proposals/econ-behaviors.js").EconomyBootstrapPowers["consume"]["economicCommitteeCreatorFacet"];
                };
            }) => Promise<void>;
            buildZoe: ({ consume: { vatAdminSvc, loadCriticalVat, client }, produce: { zoe, feeMintAccess }, brand: { produce: { Invitation: invitationBrand }, }, issuer: { produce: { Invitation: invitationIssuer }, }, }: BootstrapPowers & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<ZoeVat>>;
                };
            }) => Promise<void>;
            startPriceAuthorityRegistry: ({ consume: { loadCriticalVat, client }, produce, }: BootstrapPowers & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<PriceAuthorityVat>>;
                };
            }) => Promise<void>;
            makeOracleBrands: ({ namedVat: { consume: { agoricNames }, }, oracleBrand: { produce: { USD }, }, }: BootstrapPowers & NamedVatPowers) => Promise<void>;
            produceBoard: ({ consume: { client }, produce: { board: pBoard }, namedVat: { consume: { board: vatBoard }, }, }: BootstrapPowers & NamedVatPowers) => Promise<void>;
            makeBoard: ({ consume: { loadCriticalVat, client }, produce: { board: { resolve: resolveBoard }, }, }: BootstrapPowers & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<BoardVat>>;
                };
            }) => Promise<void>;
            produceNamesByAddress: ({ consume: { agoricNames, provisioning: provisioningOptP, client }, produce: { namesByAddress, namesByAddressAdmin }, }: BootstrapPowers) => Promise<void>;
            makeAddressNameHubs: ({ consume: { agoricNames: agoricNamesP, client }, produce, }: BootstrapSpace) => Promise<void>;
            makeClientBanks: ({ consume: { namesByAddressAdmin, client, bankManager, walletFactoryStartResult, }, }: BootstrapSpace) => Promise<void>;
            installBootContracts: ({ consume: { vatAdminSvc, zoe }, installation: { produce: { centralSupply, mintHolder }, }, }: BootstrapSpace) => Promise<void>;
            mintInitialSupply: ({ vatParameters: { argv: { bootMsg }, }, consume: { feeMintAccess: feeMintAccessP, zoe }, produce: { initialSupply }, installation: { consume: { centralSupply }, }, }: WellKnownSpaces & PromiseSpaceOf<ChainBootstrapSpaceT & {
                vatAdminSvc: VatAdminSvc;
            }, {}, {
                loadVat: VatLoader<unknown>;
                loadCriticalVat: VatLoader<unknown>;
            }> & any & {
                vatParameters: {
                    argv: {
                        bootMsg?: {
                            type: string;
                            chainID: string;
                            storagePort: number;
                            supplyCoins: {
                                denom: string;
                                amount: string;
                            }[];
                            swingsetPort: number;
                            vbankPort: number;
                            vibcPort: number;
                        } | undefined;
                    };
                };
            }) => Promise<void>;
            addBankAssets: ({ consume: { agoricNamesAdmin, initialSupply, bridgeManager: bridgeManagerP, loadCriticalVat, startUpgradable, zoe, }, produce: { bankManager, bldIssuerKit }, installation: { consume: { mintHolder }, }, issuer: { produce: produceIssuer }, brand: { produce: produceBrand }, }: BootstrapSpace & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<BankVat>>;
                };
            }) => Promise<void>;
        };
        utils: {
            agoricNamesReserved: {
                issuer: {
                    IST: string;
                    BLD: string;
                    Invitation: string;
                    AUSD: string;
                };
                installation: {
                    reserve: string;
                    centralSupply: string;
                    mintHolder: string;
                    walletFactory: string;
                    provisionPool: string;
                    auctioneer: string;
                    feeDistributor: string;
                    contractGovernor: string;
                    committee: string;
                    noActionElectorate: string;
                    binaryVoteCounter: string;
                    VaultFactory: string;
                    liquidate: string;
                    Pegasus: string;
                    psm: string;
                    scaledPriceAuthority: string;
                    stakeAtom: string;
                    stakeBld: string;
                    econCommitteeCharter: string;
                    priceAggregator: string;
                };
                instance: {
                    reserve: string;
                    walletFactory: string;
                    provisionPool: string;
                    auctioneer: string;
                    feeDistributor: string;
                    VaultFactory: string;
                    Pegasus: string;
                    stakeAtom: string;
                    stakeBld: string;
                    econCommitteeCharter: string;
                    economicCommittee: string;
                    VaultFactoryGovernor: string;
                    reserveGovernor: string;
                };
                oracleBrand: {
                    USD: string;
                };
                uiConfig: {
                    VaultFactory: string;
                };
            };
            feeIssuerConfig: FeeIssuerConfig;
            addRemote: (addr: string, { vats: { comms, vattp } }: {
                vats: {
                    vattp: VattpVat;
                    comms: CommsVatRoot;
                };
            }) => Promise<void>;
            callProperties: (builders: ((...args: any) => Record<string, unknown>)[], ...args: unknown[]) => Record<string, unknown>;
            extract: (template: true | string | Record<string, any>, specimen: unknown, path?: string[] | undefined) => any;
            extractPowers: (permit: true | string | Record<string, any>, allPowers: unknown) => any;
            runModuleBehaviors: ({ allPowers, behaviors, manifest, makeConfig, }: {
                allPowers: unknown;
                behaviors: Record<string, unknown>;
                manifest: Record<string, Record<string, unknown>>;
                makeConfig: (name: string, permit: Record<string, unknown>) => unknown;
            }) => Promise<any[]>;
            makePromiseSpaceForNameHub: (nameAdmin: ERef<import("@agoric/vats/src/types.js").NameAdmin>, log?: {
                (...data: any[]): void;
                (message?: any, ...optionalParams: any[]): void;
            } | undefined) => PromiseSpaceOf<any, {}, {}>;
            makeWellKnownSpaces: (parentAdmin: ERef<import("@agoric/vats/src/types.js").NameAdmin>, log?: {
                (...data: any[]): void;
                (message?: any, ...optionalParams: any[]): void;
            } | undefined, kinds?: string[] | undefined) => Promise<WellKnownSpaces>;
            makeAgoricNamesAccess: (log?: {
                (...data: any[]): void;
                (message?: any, ...optionalParams: any[]): void;
            } | undefined, reserved?: Record<string, Record<string, unknown>>) => Promise<{
                agoricNames: import("@agoric/vats").NameHub<any>;
                agoricNamesAdmin: import("@agoric/vats").NameAdmin;
                spaces: WellKnownSpaces;
            }>;
            makeMyAddressNameAdminKit: (address: string) => {
                nameHub: import("@agoric/vats").NameHub<any>;
                myAddressNameAdmin: import("@agoric/vats").MyAddressNameAdmin;
            };
            makeVatSpace: (svc: ERef<ReturnType<Awaited<VatAdminVat>["createVatAdminService"]>>, criticalVatKey: unknown, log?: ((...args: any) => void) | undefined, label?: string | undefined) => {
                space: {
                    consume: {
                        agoricNames: Promise<{
                            getNameHub: () => import("@agoric/vats").NameHub<any>;
                            getNameHubKit: () => import("@agoric/vats").NameHubKit;
                            publishNameHubs: (nameStorage: ERef<
                            /**
                             * @param {BootstrapPowers & {
                             *   consume: {
                             *     orchestration: OrchestrationService;
                             *   };
                             * }} powers
                             * @param {object} _options
                             */
                            StorageNode>, vatBoard: ERef<BoardVat>, kinds: string[]) => Promise<void>;
                            provideInertBrand: (keyword: string, displayInfo: DisplayInfo) => any;
                        } & import("@endo/pass-style").RemotableObject<`Alleged: ${string}`> & import("@endo/eventual-send").RemotableBrand<{}, {
                            getNameHub: () => import("@agoric/vats").NameHub<any>;
                            getNameHubKit: () => import("@agoric/vats").NameHubKit;
                            publishNameHubs: (nameStorage: ERef<StorageNode>, vatBoard: ERef<BoardVat>, kinds: string[]) => Promise<void>;
                            provideInertBrand: (keyword: string, displayInfo: DisplayInfo) => any;
                        }>>;
                        board: Promise<{
                            getBoard: () => import("@endo/exo").Guarded<{
                                getId(value: import("@endo/pass-style").RemotableObject): string;
                                getValue(id: BoardId): import("@endo/pass-style").RemotableObject;
                                lookup(...path: string[]): Promise<any>;
                                has(val: import("@endo/pass-style").RemotableObject): boolean;
                                ids(): string[];
                                getPublishingMarshaller(): import("@endo/exo").Guarded<{
                                    toCapData(val: any): import("@endo/marshal").CapData<string>;
                                    fromCapData(data: any): any;
                                    serialize(data: any): import("@endo/marshal").CapData<string>;
                                    unserialize(data: any): any;
                                }>;
                                getReadonlyMarshaller(): import("@endo/exo").Guarded<{
                                    toCapData(val: any): import("@endo/marshal").CapData<string | null>;
                                    fromCapData(data: any): any;
                                    serialize(data: any): import("@endo/marshal").CapData<string | null>;
                                    unserialize(data: any): any;
                                }>;
                            }>;
                            makePublishingRecorderKit: <T>(storageNode: StorageNode | Awaited<import("@endo/far").FarRef<StorageNode>>, valueShape?: import("@agoric/zoe/src/contractSupport/recorder.js").TypedMatcher<T> | undefined) => import("@agoric/zoe/src/contractSupport/recorder.js").RecorderKit<T>;
                            makeReadOnlyRecorderKit: <T>(storageNode: StorageNode | Awaited<import("@endo/far").FarRef<StorageNode>>, valueShape?: import("@agoric/zoe/src/contractSupport/recorder.js").TypedMatcher<T> | undefined) => import("@agoric/zoe/src/contractSupport/recorder.js").RecorderKit<T>;
                        } & import("@endo/pass-style").RemotableObject<`Alleged: ${string}`> & import("@endo/eventual-send").RemotableBrand<{}, {
                            getBoard: () => import("@endo/exo").Guarded<{
                                getId(value: import("@endo/pass-style").RemotableObject): string;
                                getValue(id: BoardId): import("@endo/pass-style").RemotableObject;
                                lookup(...path: string[]): Promise<any>;
                                has(val: import("@endo/pass-style").RemotableObject): boolean;
                                ids(): string[];
                                getPublishingMarshaller(): import("@endo/exo").Guarded<{
                                    toCapData(val: any): import("@endo/marshal").CapData<string>;
                                    fromCapData(data: any): any;
                                    serialize(data: any): import("@endo/marshal").CapData<string>;
                                    unserialize(data: any): any;
                                }>;
                                getReadonlyMarshaller(): import("@endo/exo").Guarded<{
                                    toCapData(val: any): import("@endo/marshal").CapData<string | null>;
                                    fromCapData(data: any): any;
                                    serialize(data: any): import("@endo/marshal").CapData<string | null>;
                                    unserialize(data: any): any;
                                }>;
                            }>;
                            makePublishingRecorderKit: <T>(storageNode: StorageNode | Awaited<import("@endo/far").FarRef<StorageNode>>, valueShape?: import("@agoric/zoe/src/contractSupport/recorder.js").TypedMatcher<T> | undefined) => import("@agoric/zoe/src/contractSupport/recorder.js").RecorderKit<T>;
                            makeReadOnlyRecorderKit: <T>(storageNode: StorageNode | Awaited<import("@endo/far").FarRef<StorageNode>>, valueShape?: import("@agoric/zoe/src/contractSupport/recorder.js").TypedMatcher<T> | undefined) => import("@agoric/zoe/src/contractSupport/recorder.js").RecorderKit<T>;
                        }>>;
                    };
                };
                durableStore: globalThis.MapStore<any, any>;
            };
        };
    };
} & {
    consume: {
        loadCriticalVat: VatLoader<any>;
        portAllocator: import("@endo/exo").Guarded<{
            allocateCustomIBCPort(specifiedName?: string): import("@agoric/vow").Vow<any>;
            allocateICAControllerPort(): import("@agoric/vow").Vow<any>;
            allocateICQControllerPort(): import("@agoric/vow").Vow<any>;
            allocateCustomLocalPort(specifiedName?: string): import("@agoric/vow").Vow<any>;
        }>;
    };
    produce: {
        orchestration: Producer<any>;
        orchestrationKit: Producer<any>;
        orchestrationVat: Producer<any>;
    };
}, options: {
    options: {
        orchestrationRef: VatSourceRef;
    };
}): Promise<void>;
export function addOrchestrationToClient({ consume: { client, orchestration } }: WellKnownSpaces & PromiseSpaceOf<ChainBootstrapSpaceT & {
    vatAdminSvc: VatAdminSvc;
}, {}, {
    loadVat: VatLoader<unknown>;
    loadCriticalVat: VatLoader<unknown>;
}> & {
    zone: import("@agoric/base-zone").Zone;
    devices: SoloDevices | ChainDevices;
    vats: SwingsetVats;
    vatPowers: {
        [prop: string]: any;
        D: DProxy<any>;
    };
    vatParameters: BootstrapVatParams;
    runBehaviors: (manifest: unknown) => Promise<unknown>;
    modules: {
        behaviors: {
            bridgeCoreEval: (allPowers: BootstrapPowers) => Promise<void>;
            makeProvisioner: ({ consume: { clientCreator, loadCriticalVat }, vats: { comms, vattp }, produce: { provisioning }, }: BootstrapPowers & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<ProvisioningVat>>;
                };
            }) => Promise<void>;
            noProvisioner: ({ produce: { provisioning } }: BootstrapPowers) => Promise<void>;
            bridgeProvisioner: ({ consume: { provisioning: provisioningP, provisionBridgeManager: provisionBridgeManagerP, provisionWalletBridgeManager: provisionWalletBridgeManagerP, }, }: BootstrapPowers) => Promise<void>;
            setupClientManager: ({ produce: { client, clientCreator: clientCreatorP } }: BootstrapSpace, { template, }?: {
                template?: Record<string, unknown>;
            }) => Promise<void>;
            startTimerService: ({ devices: { timer: timerDevice }, vats: { timer: timerVat }, consume: { client }, produce: { chainTimerService: produceTimer }, brand: { produce: { timer }, }, }: BootstrapPowers) => Promise<void>;
            makeBridgeManager: ({ consume: { loadCriticalVat }, devices: { bridge }, produce: { bridgeManager: bridgeManagerP, provisionBridgeManager, provisionWalletBridgeManager, walletBridgeManager, }, }: BootDevices<ChainDevices> & BootstrapSpace & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<ChainStorageVat>>;
                };
            }) => Promise<void>;
            makeChainStorage: ({ consume: { loadCriticalVat, bridgeManager: bridgeManagerP }, produce: { chainStorage: chainStorageP, storageBridgeManager: storageBridgeManagerP, }, }: BootstrapSpace & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<ChainStorageVat>>;
                };
            }) => Promise<void>;
            produceHighPrioritySendersManager: ({ consume: { loadCriticalVat, storageBridgeManager: storageBridgeManagerP }, produce: { highPrioritySendersManager: managerP }, }: BootstrapSpace & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<ChainStorageVat>>;
                };
            }) => Promise<void>;
            publishAgoricNamesToChainStorage: ({ consume: { chainStorage: rootP }, namedVat: { consume: { agoricNames, board: vatBoard }, }, }: BootstrapPowers & NamedVatPowers) => Promise<void>;
            publishAgoricNames: ({ consume: { agoricNamesAdmin, board, chainStorage: rootP } }: BootstrapPowers, { options: { agoricNamesOptions } }?: {
                options?: {
                    agoricNamesOptions?: {
                        topLevel?: string[];
                    };
                };
            }) => Promise<void>;
            connectChainFaucet: ({ consume: { client } }: BootstrapPowers) => Promise<void>;
            makeVatsFromBundles: ({ vats, devices, consume: { vatStore }, produce: { vatAdminSvc, loadVat, loadCriticalVat }, }: BootstrapPowers & {}) => Promise<void>;
            produceDiagnostics: ({ produce }: Pick<ChainBootstrapSpace, "produce">) => Promise<void>;
            produceStartUpgradable: ({ zone, consume: { diagnostics, zoe }, produce, }: BootstrapSpace & {
                zone: import("@agoric/zone").Zone;
            }) => Promise<void>;
            produceStartGovernedUpgradable: ({ zone, consume: { chainTimerService, diagnostics, economicCommitteeCreatorFacet, zoe, }, produce, installation: { consume: { contractGovernor }, }, }: BootstrapSpace & {
                zone: import("@agoric/zone").Zone;
                consume: {
                    economicCommitteeCreatorFacet: import("@agoric/inter-protocol/src/proposals/econ-behaviors.js").EconomyBootstrapPowers["consume"]["economicCommitteeCreatorFacet"];
                };
            }) => Promise<void>;
            buildZoe: ({ consume: { vatAdminSvc, loadCriticalVat, client }, produce: { zoe, feeMintAccess }, brand: { produce: { Invitation: invitationBrand }, }, issuer: { produce: { Invitation: invitationIssuer }, }, }: BootstrapPowers & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<ZoeVat>>;
                };
            }) => Promise<void>;
            startPriceAuthorityRegistry: ({ consume: { loadCriticalVat, client }, produce, }: BootstrapPowers & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<PriceAuthorityVat>>;
                };
            }) => Promise<void>;
            makeOracleBrands: ({ namedVat: { consume: { agoricNames }, }, oracleBrand: { produce: { USD }, }, }: BootstrapPowers & NamedVatPowers) => Promise<void>;
            produceBoard: ({ consume: { client }, produce: { board: pBoard }, namedVat: { consume: { board: vatBoard }, }, }: BootstrapPowers & NamedVatPowers) => Promise<void>;
            makeBoard: ({ consume: { loadCriticalVat, client }, produce: { board: { resolve: resolveBoard }, }, }: BootstrapPowers & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<BoardVat>>;
                };
            }) => Promise<void>;
            produceNamesByAddress: ({ consume: { agoricNames, provisioning: provisioningOptP, client }, produce: { namesByAddress, namesByAddressAdmin }, }: BootstrapPowers) => Promise<void>;
            makeAddressNameHubs: ({ consume: { agoricNames: agoricNamesP, client }, produce, }: BootstrapSpace) => Promise<void>;
            makeClientBanks: ({ consume: { namesByAddressAdmin, client, bankManager, walletFactoryStartResult, }, }: BootstrapSpace) => Promise<void>;
            installBootContracts: ({ consume: { vatAdminSvc, zoe }, installation: { produce: { centralSupply, mintHolder }, }, }: BootstrapSpace) => Promise<void>;
            mintInitialSupply: ({ vatParameters: { argv: { bootMsg }, }, consume: { feeMintAccess: feeMintAccessP, zoe }, produce: { initialSupply }, installation: { consume: { centralSupply }, }, }: WellKnownSpaces & PromiseSpaceOf<ChainBootstrapSpaceT & {
                vatAdminSvc: VatAdminSvc;
            }, {}, {
                loadVat: VatLoader<unknown>;
                loadCriticalVat: VatLoader<unknown>;
            }> & any & {
                vatParameters: {
                    argv: {
                        bootMsg?: {
                            type: string;
                            chainID: string;
                            storagePort: number;
                            supplyCoins: {
                                denom: string;
                                amount: string;
                            }[];
                            swingsetPort: number;
                            vbankPort: number;
                            vibcPort: number;
                        } | undefined;
                    };
                };
            }) => Promise<void>;
            addBankAssets: ({ consume: { agoricNamesAdmin, initialSupply, bridgeManager: bridgeManagerP, loadCriticalVat, startUpgradable, zoe, }, produce: { bankManager, bldIssuerKit }, installation: { consume: { mintHolder }, }, issuer: { produce: produceIssuer }, brand: { produce: produceBrand }, }: BootstrapSpace & {
                consume: {
                    loadCriticalVat: ERef<VatLoader<BankVat>>;
                };
            }) => Promise<void>;
        };
        utils: {
            agoricNamesReserved: {
                issuer: {
                    IST: string;
                    BLD: string;
                    Invitation: string;
                    AUSD: string;
                };
                installation: {
                    reserve: string;
                    centralSupply: string;
                    mintHolder: string;
                    walletFactory: string;
                    provisionPool: string;
                    auctioneer: string;
                    feeDistributor: string;
                    contractGovernor: string;
                    committee: string;
                    noActionElectorate: string;
                    binaryVoteCounter: string;
                    VaultFactory: string;
                    liquidate: string;
                    Pegasus: string;
                    psm: string;
                    scaledPriceAuthority: string;
                    stakeAtom: string;
                    stakeBld: string;
                    econCommitteeCharter: string;
                    priceAggregator: string;
                };
                instance: {
                    reserve: string;
                    walletFactory: string;
                    provisionPool: string;
                    auctioneer: string;
                    feeDistributor: string;
                    VaultFactory: string;
                    Pegasus: string;
                    stakeAtom: string;
                    stakeBld: string;
                    econCommitteeCharter: string;
                    economicCommittee: string;
                    VaultFactoryGovernor: string;
                    reserveGovernor: string;
                };
                oracleBrand: {
                    USD: string;
                };
                uiConfig: {
                    VaultFactory: string;
                };
            };
            feeIssuerConfig: FeeIssuerConfig;
            addRemote: (addr: string, { vats: { comms, vattp } }: {
                vats: {
                    vattp: VattpVat;
                    comms: CommsVatRoot;
                };
            }) => Promise<void>;
            callProperties: (builders: ((...args: any) => Record<string, unknown>)[], ...args: unknown[]) => Record<string, unknown>;
            extract: (template: true | string | Record<string, any>, specimen: unknown, path?: string[] | undefined) => any;
            extractPowers: (permit: true | string | Record<string, any>, allPowers: unknown) => any;
            runModuleBehaviors: ({ allPowers, behaviors, manifest, makeConfig, }: {
                allPowers: unknown;
                behaviors: Record<string, unknown>;
                manifest: Record<string, Record<string, unknown>>;
                makeConfig: (name: string, permit: Record<string, unknown>) => unknown;
            }) => Promise<any[]>;
            makePromiseSpaceForNameHub: (nameAdmin: ERef<import("@agoric/vats/src/types.js").NameAdmin>, log?: {
                (...data: any[]): void;
                (message?: any, ...optionalParams: any[]): void;
            } | undefined) => PromiseSpaceOf<any, {}, {}>;
            makeWellKnownSpaces: (parentAdmin: ERef<import("@agoric/vats/src/types.js").NameAdmin>, log?: {
                (...data: any[]): void;
                (message?: any, ...optionalParams: any[]): void;
            } | undefined, kinds?: string[] | undefined) => Promise<WellKnownSpaces>;
            makeAgoricNamesAccess: (log?: {
                (...data: any[]): void;
                (message?: any, ...optionalParams: any[]): void;
            } | undefined, reserved?: Record<string, Record<string, unknown>>) => Promise<{
                agoricNames: import("@agoric/vats").NameHub<any>;
                agoricNamesAdmin: import("@agoric/vats").NameAdmin;
                spaces: WellKnownSpaces;
            }>;
            makeMyAddressNameAdminKit: (address: string) => {
                nameHub: import("@agoric/vats").NameHub<any>;
                myAddressNameAdmin: import("@agoric/vats").MyAddressNameAdmin;
            };
            makeVatSpace: (svc: ERef<ReturnType<Awaited<VatAdminVat>["createVatAdminService"]>>, criticalVatKey: unknown, log?: ((...args: any) => void) | undefined, label?: string | undefined) => {
                space: {
                    consume: {
                        agoricNames: Promise<{
                            getNameHub: () => import("@agoric/vats").NameHub<any>;
                            getNameHubKit: () => import("@agoric/vats").NameHubKit;
                            publishNameHubs: (nameStorage: ERef<StorageNode>, vatBoard: ERef<BoardVat>, kinds: string[]) => Promise<void>;
                            provideInertBrand: (keyword: string, displayInfo: DisplayInfo) => any;
                        } & import("@endo/pass-style").RemotableObject<`Alleged: ${string}`> & import("@endo/eventual-send").RemotableBrand<{}, {
                            getNameHub: () => import("@agoric/vats").NameHub<any>;
                            getNameHubKit: () => import("@agoric/vats").NameHubKit;
                            publishNameHubs: (nameStorage: ERef<StorageNode>, vatBoard: ERef<BoardVat>, kinds: string[]) => Promise<void>;
                            provideInertBrand: (keyword: string, displayInfo: DisplayInfo) => any;
                        }>>;
                        board: Promise<{
                            getBoard: () => import("@endo/exo").Guarded<{
                                getId(value: import("@endo/pass-style").RemotableObject): string;
                                getValue(id: BoardId): import("@endo/pass-style").RemotableObject;
                                lookup(...path: string[]): Promise<any>;
                                has(val: import("@endo/pass-style").RemotableObject): boolean;
                                ids(): string[];
                                getPublishingMarshaller(): import("@endo/exo").Guarded<{
                                    toCapData(val: any): import("@endo/marshal").CapData<string>;
                                    fromCapData(data: any): any;
                                    serialize(data: any): import("@endo/marshal").CapData<string>;
                                    unserialize(data: any): any;
                                }>;
                                getReadonlyMarshaller(): import("@endo/exo").Guarded<{
                                    toCapData(val: any): import("@endo/marshal").CapData<string | null>;
                                    fromCapData(data: any): any;
                                    serialize(data: any): import("@endo/marshal").CapData<string | null>;
                                    unserialize(data: any): any;
                                }>;
                            }>;
                            makePublishingRecorderKit: <T>(storageNode: StorageNode | Awaited<import("@endo/far").FarRef<StorageNode>>, valueShape?: import("@agoric/zoe/src/contractSupport/recorder.js").TypedMatcher<T> | undefined) => import("@agoric/zoe/src/contractSupport/recorder.js").RecorderKit<T>;
                            makeReadOnlyRecorderKit: <T>(storageNode: StorageNode | Awaited<import("@endo/far").FarRef<StorageNode>>, valueShape?: import("@agoric/zoe/src/contractSupport/recorder.js").TypedMatcher<T> | undefined) => import("@agoric/zoe/src/contractSupport/recorder.js").RecorderKit<T>;
                        } & import("@endo/pass-style").RemotableObject<`Alleged: ${string}`> & import("@endo/eventual-send").RemotableBrand<{}, {
                            getBoard: () => import("@endo/exo").Guarded<{
                                getId(value: import("@endo/pass-style").RemotableObject): string;
                                getValue(id: BoardId): import("@endo/pass-style").RemotableObject;
                                lookup(...path: string[]): Promise<any>;
                                has(val: import("@endo/pass-style").RemotableObject): boolean;
                                ids(): string[];
                                getPublishingMarshaller(): import("@endo/exo").Guarded<{
                                    toCapData(val: any): import("@endo/marshal").CapData<string>;
                                    fromCapData(data: any): any;
                                    serialize(data: any): import("@endo/marshal").CapData<string>;
                                    unserialize(data: any): any;
                                }>;
                                getReadonlyMarshaller(): import("@endo/exo").Guarded<{
                                    toCapData(val: any): import("@endo/marshal").CapData<string | null>;
                                    fromCapData(data: any): any;
                                    serialize(data: any): import("@endo/marshal").CapData<string | null>;
                                    unserialize(data: any): any;
                                }>;
                            }>;
                            makePublishingRecorderKit: <T>(storageNode: StorageNode | Awaited<import("@endo/far").FarRef<StorageNode>>, valueShape?: import("@agoric/zoe/src/contractSupport/recorder.js").TypedMatcher<T> | undefined) => import("@agoric/zoe/src/contractSupport/recorder.js").RecorderKit<T>;
                            makeReadOnlyRecorderKit: <T>(storageNode: StorageNode | Awaited<import("@endo/far").FarRef<StorageNode>>, valueShape?: import("@agoric/zoe/src/contractSupport/recorder.js").TypedMatcher<T> | undefined) => import("@agoric/zoe/src/contractSupport/recorder.js").RecorderKit<T>;
                        }>>;
                    };
                };
                durableStore: globalThis.MapStore<any, any>;
            };
        };
    };
} & {
    consume: {
        orchestration: import("@endo/exo").Guarded<{
            makeAccount(hostConnectionId: `connection-${number}`, controllerConnectionId: `connection-${number}`): Promise<import("../cosmos-api.js").IcaAccount>;
            provideICQConnection(controllerConnectionId: `connection-${number}`): Promise<import("@endo/exo").Guarded<{
                getLocalAddress(): `/ibc-port/${string}`;
                getRemoteAddress(): `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}`;
                query(msgs: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").RequestQuery>[]): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").ResponseQuery>[]>;
            }>>;
        }>;
    };
}, _options: object): Promise<void>;
export function getManifestForOrchestration(_powers: any, { orchestrationRef }: {
    orchestrationRef: any;
}): {
    manifest: {
        [x: string]: {
            consume: {
                loadCriticalVat: boolean;
                portAllocator: string;
            };
            produce: {
                orchestration: string;
                orchestrationKit: string;
                orchestrationVat: string;
            };
        };
    };
    options: {
        orchestrationRef: any;
    };
};
export type OrchestrationVats = {
    orchestration: globalThis.ERef<{
        makeOrchestrationKit(initialPowers?: Partial<import("../service.js").OrchestrationPowers> | undefined): import("@endo/exo").GuardedKit<{
            self: {
                allocateICAControllerPort(): Promise<any>;
                allocateICQControllerPort(): Promise<any>;
            };
            public: {
                makeAccount(hostConnectionId: `connection-${number}`, controllerConnectionId: `connection-${number}`): Promise<import("../cosmos-api.js").IcaAccount>;
                provideICQConnection(controllerConnectionId: `connection-${number}`): Promise<import("@endo/exo").Guarded<{
                    getLocalAddress(): `/ibc-port/${string}`;
                    getRemoteAddress(): `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}`;
                    query(msgs: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").RequestQuery>[]): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").ResponseQuery>[]>;
                }>>;
            };
        }>;
    } & import("@endo/pass-style").RemotableObject<`Alleged: ${string}`> & import("@endo/eventual-send").RemotableBrand<{}, {
        makeOrchestrationKit(initialPowers?: Partial<import("../service.js").OrchestrationPowers> | undefined): import("@endo/exo").GuardedKit<{
            self: {
                allocateICAControllerPort(): Promise<any>;
                allocateICQControllerPort(): Promise<any>;
            };
            public: {
                makeAccount(hostConnectionId: `connection-${number}`, controllerConnectionId: `connection-${number}`): Promise<import("../cosmos-api.js").IcaAccount>;
                provideICQConnection(controllerConnectionId: `connection-${number}`): Promise<import("@endo/exo").Guarded<{
                    getLocalAddress(): `/ibc-port/${string}`;
                    getRemoteAddress(): `/${string}ibc-port/${string}/ordered/${string}` | `/${string}ibc-port/${string}/unordered/${string}`;
                    query(msgs: import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").RequestQuery>[]): Promise<import("@agoric/cosmic-proto").JsonSafe<import("@agoric/cosmic-proto/tendermint/abci/types.js").ResponseQuery>[]>;
                }>>;
            };
        }>;
    }>>;
};
//# sourceMappingURL=orchestration-proposal.d.ts.map